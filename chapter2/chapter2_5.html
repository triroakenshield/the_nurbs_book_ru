<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Вычислительные алгоритмы</title>
    <link rel="stylesheet" href="../css/Pagestyle.css" />
    <style>
        ol.exe {
            counter-reset: item;
            list-style-type: none;
        }

        ol.exe li.exe:before {
            content: '2.'counter(item, decimal) '. ';
            counter-increment: item;
            font-weight: bold;
        }
    </style>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=AM_CHTML'></script>
</head>

<body>
    <div class="header">Глава II</div>
    <div class="section"><b>2.5.</b> Вычислительные алгоритмы</div>

    <p>В этом разделе мы разрабатываем алгоритмы для вычисления значений базисных функций и их производных. Пусть
        `U={u_0,…,u_m}` будет векторным узлом как в <a href="chapter2_4.html#f2_13">ур&shy;авнении (2.13)</a>, и
        предположим, что мы заинтересованы в базисных функциях степени `p`. Кроме того, предположим, u фиксирован, и
        `u∈[u_i,u_{i+1})`. Мы разрабатываем пять алгоритмов, которые вычисляют:</p>

    <ul>
        <li>индекс узловых промежутков, `i`;</li>
        <li>`N_{i-p,p}(u),…,N_{i,p}(u)`(основано на <a href="chapter2_2.html#f2_5">уравнение [2.5]</a>);</li>
        <li>`N_{i-p,p}^{(k)}(u),…,N_{i,p}^{(k)}(u)` для `k=0,…,p`; для `k>p` производные равны нулю (это алгоритм
            основан на <a href="chapter2_3.html#f2_10">уравнении [2.10]</a>);</li>
        <li>одиночная базисная функция, `N_{j,p}(u)`, где `0≤j≤m-p-1`;</li>
        <li>производные одиночной базисной функции, `N_{j,p}^{(k)}(u)`, где `0≤j≤m-p-1` и `k=0,…,p` (на основе
            <a href="chapter2_3.html#f2_9">уравнения [2.9]</a>).</li>
    </ul>

    <p>Мы представляем два алгоритма, которые вычисляют `p+1` функций до двух, вычислияющих только один, потому что они
        наиболее важны и на самом деле несколько проще.</p>
    <p>Из <a href="chapter2_2.html#pr2_2">Св.2.2</a> и в предположении, что `u∈[u_i,u_{i+1})`, следует, что мы можем
        сосредо&shy;точить наше внимание на функциях `N_{i-p,p},…,N_{i,p}` и их производных; Все остальные функции
        тождественно равны нулю, и это расточительно, чтобы фактически вычи&shy;слить их. Таким образом, первым шагом в
        оценке является определение продолжитель&shy;ности узла, в котором лежит `u`. Можно использовать либо линейный
        или двоичный поиск векторного узла; мы представляем здесь двоичный поиск. Так как мы использу&shy;ем интервалы
        вида и `u∈[u_i,u_{i+1})`, тонкая проблема в оценке базисных функций част&shy;ным случаем `u=u_m`. Лучше всего с
        этим справиться на самом низком уровне, устано&shy;вив индекс интервала `n(=m-p-1)`. Таким образом, в этом
        случае `u∈(u_{m-p-1},` `u_{m-p}]`. FindSpan это функция возвращающая целое число, которая означает индекс
        диапазона.</p>

    <p><a name="al2_1"><b>Алгоритм А2.1</b></a></p>
    <pre>
Int  FindSpan(n,p,u,U)
{ /* Определение  индекса  узлового  промежутка */
  /* Вход: n,p,u,U  */
  /* Выход: индекс  узлового  промежутка */
If  (u == U[n + 1])  return(n);  /* Особый случай */
low = p;  high = n + 1;  /* Выполняем  двоичный  поиск */
mid = (low + high)/2;
while  (u &lt; U[mid] || u >= U[mid + 1])
   {
   If  (u &lt; U[mid])  high = mid;
     else   low = mid;
   mid = (low + high)/2;
   }
return(mid);
}
    </pre>

    <p>Теперь мы укажем второй алгоритм. Предполагая, что `u` в `i`том интервале, вычисление ненулевых функций, приводит
        к перевернутой треугольной схеме</p>

    <table align="center">
        <tr>
            <td></td>
            <td></td>
            <td>`N_{i-p,p}`</td>
        </tr>
        <tr>
            <td></td>
            <td>`N_{i-1,1}`</td>
        </tr>
        <tr>
            <td>`N_{i,0}`</td>
            <td>`ldots`</td>
            <td>`vdots`</td>
        </tr>
        <tr>
            <td></td>
            <td>`N_{i,1}`</td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>`N_{i,p}`</td>
        </tr>
    </table>

    <p><b>Примеры</b></p>
    <table>
        <tr>
            <td><a name="smp2_3"><b>Пример2.3</b></a></td>
            <td>Пусть `p=2`, `U={0,0,1,2,3,4,4,5,5,}`, и `u=5⁄2` (смотри <a href="chapter2_2.html#img2_6">рисунок
                    2.6</a>). Тогда `i=4`, так `u∈[u_4,u_5)`. Таким образом, мы вычисляем

                <table align="center">
                    <tr>
                        <td></td>
                        <td></td>
                        <td>`N_{2,2}(5⁄2)`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{3,1}(5⁄2)`</td>
                    </tr>
                    <tr>
                        <td>`N_{4,0}(5⁄2)`</td>
                        <td></td>
                        <td>`N_{3,2}(5⁄2)`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{4,1}(5⁄2)`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td>`N_{4,2}(5⁄2)`</td>
                    </tr>
                </table>

                Подставляя `u=5⁄2` в <a href="chapter2_2.html#f2_5">формуле (2.5)</a> (читатель должен сделать это)
                получаем

                <table align="center">
                    <tr>
                        <td>`N_{4,0}(5/2)=1`</td>
                    </tr>
                    <tr>
                        <td>`N_{3,1}(5/2)=1/2`</td>
                        <td>`N_{4,1}(5/2)=1/2`</td>
                    </tr>
                    <tr>
                        <td>`N_{2,2}(5/2)=1/8`</td>
                        <td>`N_{3,2}(5/2)=6/8`</td>
                        <td>`N_{4,2}(5/2)=1/8`</td>
                    </tr>
                </table>

                Обратите внимание, что функции степени фиксированно равны в сумме 1 (<a
                    href="chapter2_2.html#pr2_4">Св.2.4</a>).
            </td>
        </tr>
    </table>

    <p>Это будет ясно читателю, который выполнял замены в этом примере, что есть много избыточных вычислений присущие
        <a href="#f2_5">уравнению (2.5)</a>. Например, выписывая функции второй степени в общих чертах, мы имеем</p>

    <p class="formula">`N_{i-2,2}(u)={u-u_{i-2}}/{u_i-u_{i-2}}N_{i-2,1}(u)+{u_{i+1}-u}/{u_{i+1}-u_{i-1}}N_{i-1,1}(u)`<a
            name="f2_14" class="nomer">(2.14)</a></p>
    <p class="formula">`N_{i-1,2}(u)={u-u_{i-1}}/{u_{i+1}-u_{i-1}}N_{i-1,1}(u)+{u_{i+2}-u}/{u_{i+2}-u_i}N_{i,1}(u)`<a
            name="f2_15" class="nomer">(2.15)</a></p>
    <p class="formula">`N_{i,2}(u)={u-u_i}/{u_{i+2}-u_i}N_{i,1}(u)+{u_{i+3}-u}/{u_{i+3}-u_{i+1}}N_{i+1,1}(u)`<a
            name="f2_16" class="nomer">(2.16)</a></p>

    Обратите внимание, что

    <ul>
        <li>первый член <a href="#f2_14">уравнения (2.14)</a> и последний член <a href="#f2_16">уравнения. (2.16)</a> не
            вычисляются, так как `N_{i-2,1}(u)=N_{i+1,1}(u)=0`;</li>
        <li>выражение

            <p class="formula">`(N_{i-1,1}(u))/{u_{i+1}-u_{i-1}}`</p>

            которое появляется во втором члене <a href="#f2_14">уравнения (2.14)</a> появляется в первом члене
            <a href="#f2_15">уравнения (2.15)</a>; аналогичное утверждение справедливо и для второго члена
            <a href="#f2_15">уравнения (2.15)</a> и первый член <a href="#f2_16">уравнения (2.16)</a>.

        </li>
    </ul>

    Введем обозначения

    <p class="formula">`"left"[j]=u-u_{i+1-j}` &emsp; `"right"[j]=u_{i+j}-u`</p>

    <a href="#f2_14">Уравнения (2.14) - (2.16)</a>, то

    <p class="formula">
        `N_{i-2,2}(u)={"left"[3]}/{"right"[0]+"left"[3]}N_{i-2,1}(u)+{"right"[1]}/{"right"[1]+"left"[2]}N_{i-1,1}(u)`
    </p>
    <p class="formula">
        `N_{i-1,2}(u)={"left"[2]}/{"right"[1]+"left"[2]}N_{i-1,1}(u)+{"right"[2]}/{"right"[2]+"left"[1]}N_{i,1}(u)`</p>
    <p class="formula">
        `N_{i,2}(u)={"left"[1]}/{"right"[2]+"left"[1]}N_{i,1}(u)+{"right"[3]}/{"right"[3]+"left"[0]}N_{i+1,1}(u)`</p>

    <p>Основываясь на этих наблюдениях, <a href="#al2_2">Алгоритм A2.2</a> вычисляет все отличные от нуля базисных
        функций и сохраняет их в массиве `N[0],…,N[p]`.</p>

    <p><a name="al2_2"><b>Алгоритм А2.2</b></a></p>
    <pre>
BasisFuns(i,u,p,U,N)
{ /*  Вычислить  неисчезающее  базисную  функцию  */
  /* Вход: i,u,p,U  */
  /* Выход: N  */
N[0] = 1.0;
for  (j=1; j&lt;=p; j++)
   {
   left[j] = u - U[i + 1 - j];
   right[j] = U[i + j] - u;
   saved = 0.0;
   for  (r=0; r&lt;j; r++)
      {
      temp = N[r] / (right[r + 1] + left[j - r]);
      N[r] = saved + right[r + 1]*temp;
      saved = left[j - r]*temp;
      }
   N[j] = saved;
   }
}
    </pre>

    Заметим, что <a href="#al2_2">Алгоритм A2.2</a> не только эффективен, но также гарантирует, что не будет деления на
    ноль, что может произойти с непосредственным применением <a href="#f2_5">уравнения (2.5)</a>.

    <p>Теперь к третьему алгоритму; в частности, мы хотим, чтобы вычислить все `N_{r,p}^{(k)}(u)`, для `i-p≤r≤i` и
        `0≤k≤n`, где `n≤p`. Инспекция <a href="#f2_10">уравнения (2.10)</a> показывает, что основные ингредиенты:</p>

    <ul>
        <li>перевернутый треугольник ненулевых базисных функций, вычисляемых в <a href="#al2_2">Алгоритме A2.2</a>;</li>
        <li>различия узлов (суммы: `right[r+1]+left[j-r]`), также вычисляется в <a href="#al2_2">Алгоритме A2.2</a>;
        </li>
        <li>различия `a_{k,j}`; обратите внимание, что `a_{k,j}` зависит от `a_{k-1,j}`, но не `a_{s,j}`, для
            `s&lt;k-1`.</li>
    </ul>

    <p>Рассматриваемый как двумерный массив размерности `(p+1)×(p+1)`, базисные функции вписываются в верхний
        треугольник (в том числе по диагонали), и различные узлы находятся к низу треугольника, т.е.</p>


    <table align="center" border="1" cellspacing="0">
        <tr>
            <td>`N_{i,0}(u)`</td>
            <td>`N_{i-1,1}(u)`</td>
            <td>`N_{i-2,2}(u)`</td>
        </tr>
        <tr>
            <td>`u_{i+1}-u_i`</td>
            <td>`N_{i,1}(u)`</td>
            <td>`N_{i-1,2}(u)`</td>
        </tr>
        <tr>
            <td>`u_{i+1}-u_{i-1}`</td>
            <td>`u_{i+2}-u_i`</td>
            <td>`N_{i,2}(u)`</td>
        </tr>
    </table>

    <p><b>Примеры</b></p>
    <table>
        <tr>
            <td><b>Пример2.4</b></td>
            <td>Пусть `p=2`, U`={0,0,0,1,2,3,4,4,5,5,5}`, и `u=5⁄2`. Тогда `u∈[u_4,u_5)`, и массив становится
                <p></p>
                <table align="center" border="1" cellspacing="0">
                    <tr>
                        <td>`N_{4,0}(5/2)=1`</td>
                        <td>`N_{3,1}(5/2)=1/2`</td>
                        <td>`N_{2,2}(5/2)=1/8`</td>
                    </tr>
                    <tr>
                        <td>`u_5-u_4=1`</td>
                        <td>`N_{4,1}(5/2)=1/2`</td>
                        <td>`N_{3,2}(5/2)=6/8`</td>
                    </tr>
                    <tr>
                        <td>`u_5-u_3=2`</td>
                        <td>`u_6-u_4=2`</td>
                        <td>`N_{4,2}(5/2)=1/8`</td>
                    </tr>
                </table>
                <p></p>
                Теперь вычислим `N_{4,2}^{(1)}(5⁄2)` и `N_{4,2}^{(2)}(5⁄2)`; с `i=4` в <a href="#f2_10">формуле
                    (2.10)</a>, имеем

                <p class="formula">`a_{1,0}=1/{u_6-u_4}=1/2`</p>
                <p class="formula">`a_{1,1}=-1/{u_7-u_5}=-1`</p>
                <p class="formula">`a_{2,0}=a_{1,0}/{u_5-u_4}=1/2`</p>
                <p class="formula">`a_{2,1}={a_{1,1}-a_{1,0}}/{u_6-u_5}={-1-1/2}/{4-3}=-3/2`</p>
                <p class="formula">`a_{2,2}=a_{1,1}/{u_7-u_6}=1/{4-4}=1/0`</p>
                <p class="formula">`N_{4,2}^{(1)}=2[a_{1,0}N_{4,1}(5/2)+a_{1,1}N_{5,1}(5/2)]`</p>
                и
                <p class="formula">`N_{4,2}^{(2)}=2[a_{2,0}N_{4,0}(5/2)+a_{2,1}N_{5,0}(5/2)+a_{2,2}N_{6,0}(5/2)]`</p>

                Теперь `a_{1,1}`, `a_{2,1}`, и `a_{2,2}` все используют различные узлы, которые не находится в массиве,
                но они умножаются соответственно на `N_{5,1}(5⁄2)`, `N_{5,0}(5⁄2)`, и `N_{6,0}(5⁄2)`, которые также не в
                массиве. Эти термины определены равными нулю, и мы остались с

                <p class="formula">`N_{4,2}^{(1)}=2a_{1,0}N_{4,1}(5/2)=1/2`</p>
                <p class="formula">`N_{4,2}^{(2)}=2a_{2,0}N_{4,0}(5/2)=1`</p>

                Чтобы проверить эти значения, напомним, из <a href="chapter2_2.html">Раздела 2.2</a> следует, что
                `N_{4,2}(u)=1⁄2(u-2)^2` на `u∈[2,3)`. Вычисление `N_{3,2}^{(1)}(5⁄2)`, `N_{3,2}^{(2)}(5⁄2)`,
                `N_{2,2}^{(1)}(5⁄2)`, и `N_{2,2}^{(2)}(5⁄2)` аналогично.

            </td>
        </tr>
    </table>

    <p>Основываясь на этих наблюдениях (и Пример2.4), это не трудно разработать <a href="#al2_3">Алгоритм A2.3</a>,
        который вычисляет ненулевые базисные функции и их производных, вплоть до `n`ой производной (`n≤p`). Выход в
        двумерном массиве, ders. ders[k][j] является kой производной функции `N_{i-p+j,p}`, где `0≤k≤n` и `0≤j≤p`.
        Используются два локальных массива:

        <ul>
            <li>ndu[p+1][p+1], для хранения базисных функций и узлов различия;</li>
            <li>a[2][p+1], хранит (в альтернативной форме) два наиболее недавно вычисленных ряда `a_{k,j}` и
                `a_{k-1,j}`.</li>
        </ul>
        Алгоритм позволяет избежать деления на ноль и/или использования членов не в массиве ndu[][].
    </p>

    <p><a name="al2_3"><b>Алгоритм А2.3</b></a></p>
    <pre>
DersBasisFuns(i,u,p,n,U,ders)
{ /* Вычислить  ненулевые  базисные  функции  и  их */
  /* производные. Первый  раздел  это  изменённый  A2.2 */
  /* для  хранения  функций  и  узлов  различия. */
  /* Вход: i,u,p,n,U  */
  /* Выход: ders  */
ndu[0][0] = 1.0;
for  (j=1; j&lt;=p; j++)
   {
   left[j] = u – U[i+1-j];
   right[j] = U[i+j] – u;
   saved = 0.0;
   for  (r=0; r&lt;j; r++)
      {  /*  Нижний  треугольник  */
      ndu[j][r] = right[r+1] + left[j-r];
      temp = ndu[r][j-1]/ndu[j][r];
         /*  Верхний треугольник  */
      ndu[j][r] = saved + right[r+1]*temp;
      saved = left[j-r]*temp;
      }
   ndu[j][j] = save
   }
for  (j=0; j&lt;=p; j++)  /* Загрузим  базисные  функции */
   ders[0][j] = ndu[j][p];
/* В  этом  разделе  вычисляем  производные (уравнение [2.9]) */
for  (r=0; r&lt;p; r++)  /* Цикл  по  индексу  функции */
   {
   s1 = 0; s2 = 1; /* Альтернативные  строки  в  массиве */
   a[0][0] = 1.0;
/* Цикл вычисления k-ой производной */
   for  (k=1; k&lt;=n; k++)  
      {
      D = 0.0;
      Rk = r – k;  pk = p – k;
      if  (r >= k)
         {
         a[s2][0] = a[s1][0]/ndu[pk+1][rk];
         d = a[s2][0]*ndu[rk][pk];
         }
      if  (rk >= -1)    j1 = 1;
         else           j1 = -rk;
      if  (r - 1 &lt;= pk) j2 = k - 1;
         else           j2 = p - r;
   for  (j=j1; j&lt;=j2; j++)
      {
      a[s2][j] = (a[s1][j] – a[s1][j-1])/ndu[pk+1][rk+j];
      d += a[s2][k]*ndu[rk+j][pk];
      }
   if  (r &lt;= pk)
      {
      a[s2][k] = -a[s1][k-1]/ndu[pk+1][r];
      d += a[s2][k]*ndu[r][pk];
      }
   ders[k][r] = d;
   j = s1;  s1 = s2; s2 = j;  /* Поменять местами строки */
   }
}
/* Умножьте  через  его  в  определенных  факторов */
/* (Уравнение [2.9]) */
r = p;
for  (k=1; k&lt;=n; k++)  
   {
   for  (j=0; j&lt;=p; j++)  derk[k][j] *=r;
   r *= (p - k);
   }
}
    </pre>

    <p>Обратим внимание теперь на последние два алгоритма, а именно вычисления одной базисной функции, `N_(i,p)(u)`,
        или производные, `N_(i,p)^((k))(u)`, единичной базисной функции. Решения этих задач приводят к треугольным
        таблицам вида</p>

    <table align="center">
        <tr>
            <td>`N_{i,0}`</td>
        </tr>
        <tr>
            <td></td>
            <td>`N_{i,1}`</td>
        </tr>
        <tr>
            <td>`N_{i+1,0}`</td>
            <td></td>
            <td>`N_{i,2}`</td>
        </tr>
        <tr>
            <td>`ldots`</td>
            <td></td>
            <td>`vdots`</td>
            <td>`N_{i,p}`</td>
        </tr>
        <tr>
            <td>`N_{i+p-1,0}`</td>
            <td></td>
            <td>`N_{i+p-2,2}`</td>
        </tr>
        <tr>
            <td></td>
            <td>`N_{i+p-1,1}`</td>
        </tr>
        <tr>
            <td>`N_{i+p,0}`</td>
        </tr>
    </table>

    <p><b>Примеры</b></p>
    <table>
        <tr>
            <td><b>Пример2.5</b></td>
            <td>Пусть `p=2`, `U={0,0,0,1,2,3,4,4,5,5,5}`, и `u=5⁄2`. Расчет `N_{3,2}(5⁄2)` дает

                <table align="center">
                    <tr>
                        <td>`N_{3,0}(5⁄2)=0`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{3,1}(5⁄2)=1/2`</td>
                    </tr>
                    <tr>
                        <td>`N_{4,0}(5⁄2)=1`</td>
                        <td></td>
                        <td>`N_{3,2}(5⁄2)=6/8`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{4,1}(5⁄2)=1/2`</td>
                    </tr>
                    <tr>
                        <td>`N_{5,0}(5⁄2)=0`</td>
                    </tr>
                </table>

                `N_{4,2} (5⁄2)` получают из

                <table align="center">
                    <tr>
                        <td>`N_{4,0}(5⁄2)=1`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{4,1}(5⁄2)=1/2`</td>
                    </tr>
                    <tr>
                        <td>`N_{5,0}(5⁄2)=0`</td>
                        <td></td>
                        <td>`N_{4,2}(5⁄2)=1/8`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{5,1}(5⁄2)=0`</td>
                    </tr>
                    <tr>
                        <td>`N_{6,0}(5⁄2)=0`</td>
                    </tr>
                </table>

            </td>
        </tr>
    </table>

    Обратите внимание, что положение и относительное количество ненулевых элементов в таблице зависит от `p` и на
    позиции 1 в первом столбце. <a href="#al2_4">Алгоритм A2.4</a> вычисляет только ненулевые элементы. Значение
    `N_{i,p}(u)` возвращается в Nip; `m` является высокий индекс `U`(`m+1` узлов). Алгоритм похож на
    <a href="#al2_2">Алгоритм A2.2</a> в использовании переменных temp и saved.

    <p><a name="al2_4"><b>Алгоритм А2.4</b></a></p>
    <pre>
OneBasisFuns(p,m,U,i,u,Nip)
{ /* Вычислить  базисную  функцию */
  /* Вход: p,m,U,i,u */
  /* Выход: Nip */
if ((i == 0 && u == U[0]) ||      /* Частный */
     (i == m-p-1 && u == U[m])  /* случай */
   {
   Nip = 1.0; return;
   }
If (u &lt; U[i] || u >= U[i+p+1])   /* Локальное  свойство */
   {
   Nip = -.0; return;
   }
for (j=0; j&lt;=p; j++) /* Инициализация  функций  нулевой  степени */
   if (u >= U[i+j] && u &lt; U[i+j+1]) N[j] = 1.0;
      else   N[j] = 0.0;
for (k=1; k&lt;=p; k++)  /* Вычислить  треугольную  таблицу */
   {
   if (N[0] == 0.0)   saved = 0.0;
      else   saved = ((u-U[i])*N[0])/(U[i+k]-U[i]);
   for (j=0; j&lt;=p-k+1; j++)
      {
      Uleft = U[i+j+1];
      Uright = U[i+j+k+1]
      If (N[j+i] == 0.0)
        {
         N[j] = saved; saved = 0.0;
        }
         else
         {
         temp = N[j+1]/(Uright-Uleft);
         N[j] = saved+(Uright-u)*temp;
         saved = (u- Uleft)*temp;
        }
      }
   }
Nip = N[0];
}        
    </pre>

    <p>Теперь для фиксированной `i`, вычисление производных, `N_{i,p}^{(k)}(u)`, для `k=0,…,n`, `n≤p`, использует
        <a href="#f2_9">уравнение (2.9)</a>. Например, если `p=3` и `n=3`, то</p>

    <p class="formula">`N_{i,3}^{(1)}=3(N_{i,2}/(u_{i+3}-u_i)-N_{i+1,2}/(u_{i+4}-u_{i+1}))`</p>
    <p class="formula">`N_{i,3}^{(2)}=3(N_{i,2}^{(1)}/(u_{i+3}-u_i)-N_{i+1,2}^{(1)}/(u_{i+4}-u_{i+1}))`</p>
    <p class="formula">`N_{i,3}^{(3)}=3(N_{i,2}^{(2)}/(u_{i+3}-u_i)-N_{i+1,2}^{(2)}/(u_{i+4}-u_{i+1}))`</p>

    Используя треугольные таблицы, мы должны вычислить

    <table>
        <tr>
            <td>`k=0:`</td>
            <td></td>
        <tr>
            <td></td>
            <td>
                <table>
                    <tr>
                        <td>`N_{i,0}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i,1}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+1,0}`</td>
                        <td></td>
                        <td>`N_{i,2}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i+1,1}`</td>
                        <td></td>
                        <td>`N_{i,3}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+2,0}`</td>
                        <td></td>
                        <td>`N_{i+1,2}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i+2,1}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+3,0}`</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td>`k=1:`</td>
            <td></td>
        <tr>
            <td></td>
            <td>
                <table>
                    <tr>
                        <td>`N_{i,2}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i,3}^{(1)}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+1,2}`</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td>`k=2:`</td>
            <td></td>
        <tr>
            <td></td>
            <td>
                <table>
                    <tr>
                        <td>`N_{i,1}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i,2}^{(1)}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+1,1}`</td>
                        <td></td>
                        <td>`N_{i,2}^{(2)}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i+1,2}^{(1)}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+2,1}`</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td>`k=3:`</td>
            <td></td>
        <tr>
            <td></td>
            <td>
                <table>
                    <tr>
                        <td>`N_{i,0}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i,1}^{(1)}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+1,0}`</td>
                        <td></td>
                        <td>`N_{i,2}^{(2)}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i+1,1}^{(1)}`</td>
                        <td></td>
                        <td>`N_{i,3}^{(3)}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+2,1}`</td>
                        <td></td>
                        <td>`N_{i+1,2}^{(2)}`</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>`N_{i+2,1}^{(1)}`</td>
                    </tr>
                    <tr>
                        <td>`N_{i+3,0}`</td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>

    <p>На словах алгоритм:
        <ol>
            <li>вычислить и сохранить всю соответствующую треугольную таблицу;</li>
            <li>чтобы получить `k`-ую производной, загрузите столбец таблицы, которая содержит функции степени `p-k`, и
                вычислить оставшуюся часть треугольника.</li>

        </ol>

    </p>
    <p><a href="#al2_5">Алгоритм A2.5</a> вычисляет `N_{i,p}^{(k)}(u)` для `k=0,…,n`,`n≤p`. `k`-ая производная
        возвращается в ders[k].</p>

    <p><a name="al2_5"><b>Алгоритм А2.5</b></a></p>
    <pre>
DersOneBasisFuns(p,m,U,i,u,n,ders)
{ /* Вычислить  производных  базисной  функции  Nip */
  /* Вход: p,m,U,i,u,n */
  /* Выход: ders */
if (u &lt; U[i] || u >= U[i+p+1])  /* Локальное  свойство */
   {
   for  (k=0; k&lt;=n; k++)   ders[k] = 0.0;
   return;
   }
for (j=0; j&lt;=p; j++)  /* Инициализация  функций  нулевой  степени */
   if (u >= U[i+j] && u &lt; U[i+j+1])  N[j][0] = 1.0;
     else   N[j][0] = 0.0;
for (k=0; k&lt;=p; k++)  /* Вычислить  полную  треугольную  таблицу */
   {
   if (N[0][k-1] == 0.0)   saved = 0.0;
      else  saved = ((u – U[i])*N[0][k-1])/(U[i+k] - U[i]);
   for (j=0; j&lt;p-k+1; j++)
      {
      Uleft = U[i+j+1];
      Uright = U[i+j+k+1];
      if (N[j+1][k-1] == 0.0)
         {
         N[j][k] = saved; saved = 0.0;
         }
         else
         {
         temp = N[j+1][k-1]/(Uright-Uleft);
         N[j][k] = saved+(Uright-u)*temp;
         Saved = (u-Uleft)*temp;
         }
      }
   }
ders[0] = N[0][p]; /* Значение  функций */
for (k=1; k&lt;=n; k++)  /* Вычисление  производных */
   {
   for (j=0; j&lt;k; j++)  /* Загрузка  соответствующей  колонки */
      ND[j] = N[j][p-k];
   for (jj=1; jj&lt;=k; jj++) /* Вычислить  таблицу  ширины  k */
      {
      if (ND[0] == 0.0)  saved = 0.0;
         else      saved = ND[0]/(U[i+p-k+jj]-U[i]);
      for (j=0; j&lt;k-jj+1; j++)
         {
         Uleft = U[i+j+1];
         Uright = U[i+j+p+jj+1];
         if (ND[j+1] == 0.0)
            {
            ND[j] = (p-k+jj)*saved;   saved = 0.0;
            }
            else
            {
            temp = ND[j+1]/(Uright-Uleft);
            ND[j] = (p-k+jj)*( saved-temp);
            saved =temp;
            }
      }
   ders[k] = ND[0];  /* k-ая  производная */
   }
}        
    </pre>

    <p>Наконец, отметим, что <a href="#al2_3">Алгоритмы A2.3</a> и <a href="#al2_5">A2.5</a> вычисляют производные с
        права, если `u` есть узел. Тем не менее, <a href="#f2_5">уравнения (2.5)</a>, <a href="#f2_9">(2.9)</a>,
        <a href="#f2_10">(2.10)</a>, и другие в этой главе мож&shy;но было бы определить с помощью интервалов вида и
        `u∈(u_i,u_{i+1}]`. Это не изменит <a href="#al2_2">Алгоритмы A2.2</a> через <a href="#al2_5">A2.5</a>. Другими
        словами, производные слева можно найти, просто имея алгоритм использующий интервалы в форме `(u_i,u_{i+1}]`,
        вместо `[u_i,u_{i+1})`. В предыдущем примере, с `p=2` и `U={0,0,0,1,2,3,4,4,5,5,5}`, если `u=2`, то охватывают
        `i=3` следует производные от левой, и `i=4` урожайность производные с правой стороны.</p>

    <p><b>Упражнения</b></p>

    <ol class="exe">
        <li class="exe">Рассмотрим линейные и квадратичные функции, вычисленные ранее и показанные на
            <a href="#img2_5">рисунках 2.5</a> и <a href="#img2_6">2.6</a>. Подставим `u=5⁄2` в полиномиальные
            уравнения, чтобы получить `N_{3,1}(5⁄2)`, `N_{4,1}(5⁄2)`, `N_{2,2}(5⁄2)`, `N_{3,2}(5⁄2)` , и
            `N_{4,2}(5⁄2)`). Что вы заметили в сумме двух линейных и сумме трех квадратичных функций?</li>
        <li class="exe">Рассмотрим квадратичные функции на <a href="#img2_6">рисунке 2.6</a>. Используя
            полино&shy;миальные выражения для `N_{3,2}(5⁄2)`, оцените функцию и ее первую и вторую производные при `u=2`
            как слева, так и справа. Соблюдайте преемственность. Имеет ли <a href="#pr2_5">свойство P2.5</a>? Сделайте
            то же самое с `N_{4,2}(u)` при `u=4`.
        </li>
        <li class="exe">Пусть `U={0,0,0,0,1,2,3,4,4,5,5,5,5}`. Как это меняет функции степени 0, 1 и 2 на
            <a href="#img2_4">рисунках 2.4</a>-<a href="#img2_6">2.6</a>? Вычислить и нарисовать девять кубических
            базисных функций, связанных с `U`.</li>
        <li class="exe">Рассмотрим функцию `N_{2,2}(u)` на <a href="#img2_5">рисунке 2.5</a>, `N_{2,2}(u)=1⁄2u^2` на
            `[0,1)`, `-3⁄2+3u-u^2` на `[1,2)` и `1⁄2(3 - u)^2` на `[2,3)`. Используйте <a href="#f2_10">формулу
                (2.10)</a>, чтобы получить выражения для первой и второй производных `N_{2,2}(u)`</li>
        <li class="exe">Снова рассмотрим? `N_{2,2}(u)` на <a href="#img2_5">рисунке 2.5</a>. Получите первые
            производ&shy;ные `N_{2,1}` и `N_{3,1}`, напрямую дифференцируя выражения полинома. Затем используйте их
            вместе с <a href="#f2_11">уравнением. (2.11)</a>, чтобы получить `N_{2,2}^'`</li>
        <li class="exe"><a name="upr2_6"></a>Снова пусть `p = 2`, `u=5⁄2` `U={0,0,0,1,2,3,4,4,5,5,5}`. Перейдите вручную
            с помощью <a href="#al2_2">алгоритма A2.2</a>, чтобы найти значения трех ненулевых базисных функций.
            Проследите по <a href="#al2_3">алгоритму A2.3</a>, чтобы найти первую и вторую производные базисных функций.
        </li>
        <li class="exe"> Используйте те же `p` и `U`, что и в <a href="#upr2_6">упражнении 2.6</a>, с `u=2`. Трассировка
            по <a href="#al2_3">алгоритму A2.3</a> с `n=1`, один раз с `i=3` и один раз с `i=4`. Затем
            дифферен&shy;цируйте соответствующие полиномиальные выражения для `N_{j,2}`, приведен&shy;ных в
            <a href="chapter2_2.html">разделе 2.2</a>, и оцените производные слева и справа при `u=2`. Сравните
            результаты с результатами, полученными из <a href="#al2_3">алгоритма А2.3</a>.</li>
        <li class="exe">Используя те же `p` и `U`, что и в <a href="#upr2_6">упражнении 2.6</a>, пусть `u=4`. Проведите
            через <a href="#al2_2">алгоритмы A2.2</a> и <a href="#al2_3">A2.3</a> , чтобы убедиться, что нет проблем с
            двойными узлами.</li>
        <li class="exe">При тех же значениях `p` и `U`, что и в <a href="#upr2_6">упражнении 2.6</a>, пусть `u=5⁄2` -
            трассировка по <a href="#al2_5">алгоритму A2.5</a> и вычисление производных `N_{4,2}^{(k)}(5⁄2)` для
            `k=0,1,2`.</li>
    </ol>

    <footer>
        <a href="chapter2_4.html">Назад</a>
        <a href="..\сontents.html">Содержание</a>
        <a href="..\chapter3\chapter3_1.html">Вперёд</a>
    </footer>
</body>

</html>