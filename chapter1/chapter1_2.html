<!DOCTYPE html>
<html lang="ru">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Основные формы Кривой</title>
  <link rel="stylesheet" href="../css/Pagestyle.css" />
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=AM_CHTML' async></script>
</head>

<body>
  <div class="header">Глава I</div>
  <div class="section"><b>1.2.</b> Основные формы Кривой</div>
  <p>Очевидно, позволяя координатным функциям `x(u)`, `y(u)` и `z(u)`, быть произволь&shy;ными, мы получаем большое
    разнообразие кривых. Тем не менее, есть компромиссы в ходе реализации геометрической системы моделирования.
    Идеальной является ситуа&shy;ция, позволяющая ограничиться классом функций, таким как:</p>
  <ul>
    <li>Способны точно представлять все кривые пользователей в необходимой системе;</li>
    <li>Легко, эффективно, и точно обработать на компьютере, в частности:
      <ul>
        <li class="tire">Эффективно вычислять точки и производные кривых</li>
        <li class="tire">Вычисление функции относительно нечувствительно к ошибкам округления операций с плавающей
          запятой</li>
        <li class="tire">Функции требуют мало памяти для хранения</li>
      </ul>
    </li>
    <li>Простые и математически понятные</li>
  </ul>
  <p>Широко используемый класс функций - полиномы. Хотя они удовлетворяют пос&shy;лед&shy;ним двум критериям в этом
    списке, существует ряд важных типов кривых (поверх&shy;нос&shy;тей), которые не могут быть точно представлены с
    использованием полиномов; эти кривые должны быть приближены в системе с помощью полиномов. В этом и следую&shy;щих
    разделах мы рассмотрим два общих метода выражения полиномиальных функций, базисную и Безье. Хотя они математически
    эквивалентны, но мы увидим, что метод Безье гораздо лучше подходит для представления и управления формой в
    компьютере.</p>
  <p>Базисная кривая `n`-й степени задается:</p>

  <p class="formula">
    `C(u)=(x(u),y(u),z(u))=sum_(i=0)^n a_iu^i` &emsp; `0&lt;=u&lt;=1` <a name="f1_5" class="nomer">(1.5)</a>
  </p>

  <p>Где `a_i=(x_i,y_i,z_i)` вектор, следовательно</p>

  <p class="formula">
    `x(u)=sum_(i=0)^n x_iu^i` &emsp; `y(u)=sum_(i=0)^n y_iu^i` &emsp; `z(u)=sum_(i=0)^n z_iu^i`
  </p>

  <p>И в матричной форме и <a href="#f1_5">уравнения (1.5)</a></p>

  <p class="formula">
    `C(u)=[a_0 a_1 ... a_n][[1],[u],[vdots],[u^n]]=[a_i]^T[u^i]`
    <a name="f1_6" class="nomer">(1.6)</a>
  </p>

  <p>(Мы пишем вектор-строку как транспонированной вектор-столбец)</p>

  <p>Дифференцируя <a href="#f1_5">Ур. (1.5)</a> получаем</p>

  <p class="formula">
    `a_i={C^(i)(u)|_{u=0}}/{i!}`
  </p>

  <p>Где `C^((i)) (u)|_{u=0}` `i`’ая производная от `C(u)` по `u=0`. Функция `n+1`, `{u^i}`, называется базисной (или
    смешивающей) функцией, и `{a_i}` коэффициент степени представления базиса.</p>
  <p>Дано `u_0`, рассчитать точку `C(u_0)` на степенной базисной кривой наиболее эффективно с использование метода
    Хорнера.
  </p>
  <ul>
    <li>Для степени = 1 : `C(u_0 )=a_1 u_0+a_0`</li>
    <li>Для степени = 2 : `C(u_0 )=(a_2 u_0+a_1)u_0+a_0`</li>
    <li>`vdots`</li>
    <li>Для степени = n : `C(u_0 )=(⋯(a_n u_0+a_(n-1) ) u_0+a_(n-2))u_0+⋯+a_0`</li>
  </ul>
  <p>Основной алгоритм</p>
  <p><a name="al1_1"><b>Алгоритм А1.1</b></a></p>
  <pre>
Horner1(a, n, u0, C)
{  /* Вычисление точки на степенной базисной кривой */
   /* Вход: a, n, u0*/
   /* Выход: C*/
C = a[n];
for (i=n-1; i>=0; i--)
   C=C*u0 + a[i];
}
  </pre>
  <p><b>Примеры</b></p>
  <table>
    <tr>
      <td><b>Пример1.1</b></td>
      <td>`n=1`. `C(u)=a_1 u_0+a_0`, `0&lt;=u&lt;=1`, это линейный сегмент между точками `a_0` и `a_0+a_1`
        <a href="#img1_5"> (рисунок 1.5)</a>. Константа `C'(u)=a_1` даёт направление линии</td>
    </tr>
    <tr>
      <td><b>Пример1.2</b></td>
      <td>`n=2`. В общем, `C(u)=a_0+a_1 u+a_2 u^2`, `0&lt;=u&lt;=1`, это параболическая дуга между точками `a_0` и
        `a_0+a_1+a_2` <a href="#img1_6">(рисунок 1.6)</a> Это показано
        <ol>
          <li>Преобразованием `C(u)` в плоскости `xy` (`C(u)` не лежит в уникальной плоскости);</li>
          <li>Установим `x=x_0+x_1 u+x_2 u^2` и `y=y_0+y_1 u+y_2 u^2`, этим мы устраним `u` и `u^2` из этих уравнений,
            что бы получить неявное уравнение второй степени по `x` и `y`;</li>
          <li>Отметим, что форма неявного уравнения - парабола.</li>
        </ol>
        <a name="img1_5">
          <object id="svg1_5" data="svg/fig1_5.html" type="image/svg+xml" align="left"></object>
          <p class="pictxt">Рисунок 1.5. Прямой линейный сегмент `C(u)=a_0+a_1u`</p>
        </a>
        <a name="img1_6">
          <object id="svg1_6" data="svg/fig1_6.html" type="image/svg+xml" width="340" height="440"></object>
          <p class="pictxt">Рисунок 1.6. Параболическая дуга `C(u)=a_0+a_1u+a_2u^2`</p>
        </a>
        <p>Обратите внимание, что вектор ускорения, `C''(u)=2a_2`, является постоянным. Есть два специальных
          (вырожденных) интересных случая, оба возникают, когда вектор `a_2` параллелен начальному вектору
          касате&shy;льной, `a_1` (когда `x_1 y_2=x_2 y_1`). В этом случае, вектор, касательный не включается, то есть,
          мы получаем прямую линию, вектор `a_2` может ука&shy;зать в том же направлении, что и `a_1`
          <a href="#img1_7a">(рис 1.7а)</a>, или в обратном напра&shy;влении <a href="#img1_7b">(рис. 1.7б)</a>. На рис
          1.7б, `a_1+2a_2 u_0=0` для некоторого `0&lt;=u&lt;=1` (скорость стремится к нулю, остановка частицы), а часть
          отрезка будет проследить в обратном направлении.
        </p>
        <a name="img1_7a">
          <object id="svg1_7a" data="svg/fig1_7a.html" type="image/svg+xml" width="500" height="200"></object>
          <p class="pictxt">Рисунок 1.7. `a_1` и `a_2` параллельны. В одном направлении</p>
        </a>
        <a name="img1_7b">
          <object id="svg1_7b" data="svg/fig1_7b.html" type="image/svg+xml" width="500" height="300"></object>
          <p class="pictxt">Рисунок 1.7. В противоположном</p>
        </a>
      </td>
    </tr>
    <tr>
      <td><b>Пример1.3</b></td>
      <td>n=3. Кубическая, `C(u)=a_0+a_1 u+a_2 u^2+a_3 u^3`, является очень рас&shy;про&shy;странённой кривой, не лежит
        на одной прямой <a href="#img1_8">(рис 1.8а)</a>; она может иметь точки перегиба <a href="#img1_8">(рис 1.8б)</a>;
        выступы <a href="#img1_8">(рис 1.8в)</a>; или петли <a href="#img1_8">(рис 1.8г)</a>. Самопересекающиеся кривая
        получается, если `a_0`, `a_1`, `a_2`, `a_3` не лежат на одной прямой. Точка перегиба на плоской кривой
        определяется как точка, где кривая гладкая (без выступов) и касательная в этой точке проходит через кривую. Это
        влечет за собой изменение в направлении поворота кривой. В точке перегиба, либо `C''(u)=0`, или
        `C'(u)|\|C''(u)`. Необходимым (но не достаточным) условием для пика в `u=u_0` является `C'(u_0)=0` (нулевая
        скорость). Условия возник&shy;новения петель также известны.

        <a name="img1_8">
          <iframe frameborder="0" seamless src="aframe/img1_8a.html" allowfullscreen="yes" allowvr="yes" vspace="500"
            width="600" height="500" align="left"> Ваш браузер не поддерживает плавающие фреймы!
          </iframe>

          <object id="svg1_8b" data="svg/fig1_8b.html" type="image/svg+xml" width="600" height="520"></object>
          <object id="svg1_8c" data="svg/fig1_8c.html" type="image/svg+xml" width="400" height="400"></object>
          <object id="svg1_8d" data="svg/fig1_8d.html" type="image/svg+xml" width="400" height="400"></object>

          <p class="pictxt">Рисунок 1.8. Кубические кривые, (а) трехмерные витые; (б) точка перегиба; (в) острие; (г)
            петля.</p>
        </a>
      </td>
    </tr>
  </table>
  <footer>
    <a href="chapter1_1.html">Назад</a>
    <a href="..\сontents.html">Содержание</a>
    <a href="chapter1_3.html">Вперёд</a>
  </footer>
</body>

</html>