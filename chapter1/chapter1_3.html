<!DOCTYPE html>
<html lang="ru">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Кривые Безье</title>
  <link rel="stylesheet" href="../css/Pagestyle.css" />
  <style>
    table.tbl {
      border-top: 1px solid;
      /* Линия сверху текста */
      border-bottom: 1px solid;
      /* Линия снизу текста */
    }
  </style>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=AM_CHTML'></script>
</head>

<body>
  <div class="header">Глава I</div>
  <div class="section"><b>1.3.</b> Кривые Безье</div>
  <p>Далее мы изучим другую параметрическую многочеленную кривую, кривую Бе&shy;зье. Так как они обе используют полиномы
    для их координатных функций, степенная базисная и Безье формы математически эквивалентны; т.е. любая кривая, которая
    мо&shy;жет быть представлена в одной, также может быть представлена в другой форме. Тем не менее, метод Безье
    превосходит степенную базисную форму для геометри&shy;че&shy;ского моделирования. Наша презентация кривых Безье,
    будет неформальной; для более стро&shy;го&shy;го и полного ознакомления читатель должен ознакомится с другой
    литературой [<a href="..\references.html#Forr72">Forr72</a>; <a href="..\references.html#Bezi72">Bezi72</a>,
    <a href="..\references.html#Bezi86">Bezi86</a>; <a href="..\references.html#Gord74a">Gord74a</a>;
    <a href="..\references.html#Chan81">Chan81</a>; <a href="..\references.html#Fari93">Fari93</a>;
    <a href="..\references.html#Yama88">Yama88</a>; <a href="..\references.html#Hosc93">Hosc93</a>;
    <a href="..\references.html#Roge90">Roge90</a>].</p>
  <p>Степенная базисная форма имеет следующие недостатки:</p>
  <ul>
    <li>это неестественно для интерактивной разработки фигуры; коэффициенты `{a_i}` сообщают очень мало геометрического
      представления о форме кривой. Кроме того, разработчик, как правило, хочет, задавать граничные условия на обоих
      концах кривой, а не только в начальной точке;</li>
    <li>алгоритмы вычисления степенных базисных полиномов имеют алгебраическое, а не геометрическое выражение (например,
      метод Горнера);</li>
    <li>численно, это довольно плохая функция; например, метод Гомера склонен к ошибкам округления, если коэффициенты
      сильно различаются по величине.</li>
  </ul>
  <p>Метод Безье исправляет эти недостатки.</p>
  <p>Кривая Безье `n`-ой степени определяется так</p>
  <p class="formula">
    `C(u)=sum_(i=0)^n B_{i,n}(u)P_i` &emsp; `0&lt;=u&lt;=1` <a name="f1_7" class="nomer">(1.7)</a>
  </p>

  <p>Базисная (смешивающая) функция, `{B_(i,n) (u)}`, это классический Многочлен Бернштейна n-ой степени (<a
      href="..\references.html#Bern12">Bern12</a>; <a href="..\references.html#Lore86">Lore86</a>) заданный так</p>
  <p class="formula"> `B_{i,n}(u)={n!}/{i!(n-1)!}u^i(1-u)^{n-1}` <a name="f1_8" class="nomer">(1.8)</a>
  </p>
  <p>Геометрические коэффициенты этой функции, `{P_i}`, называются контрольными точками. Обратите внимание, что в
    определении <a href="#f1_7">уравнения (1.7)</a>, требуется, чтобы `u∈[0,1]`.</p>
  <p><b>Примеры</b></p>
  <table>
    <tr>
      <td><b>Пример1.4</b></td>
      <td>`n=1`. Из <a href="#f1_8">уравнения (1.8)</a> мы имеем `B_(0, 1) (u)=1-u` и `B_(1, 1) (u)=u`; и из
        <a href="#f1_7">уравнения (1.7)</a> получим следующую функцию `C(u)=(1-u)P_0+``uP_1`. Это прямой линейный
        сегмент между точками `P_0` и `P_1` (смотри <a href="#img1_9">рисунок 1.9</a>).
        <a name="img1_9">
          <object id="svg1_9" data="svg/fig1_9.html" type="image/svg+xml" width="500" height="120"></object>
          <p class="pictxt">Рисунок 1.9. Кривая Безье первой степени</p>
        </a>
      </td>
    </tr>
    <tr>
      <td><b>Пример1.5</b></td>
      <td>`n=2`. Из <a href="#f1_7">уравнения (1.7)</a> и <a href="#f1_8">(1.8)</a> мы имеем `C(u)=(1-u)^2
        P_0+``2u(1-u)P_1+u^2 P_2`. Это параболическая дуга от `P_0`
        к `P_2` (смотри <a href="#img1_10">рис 1.10</a>). Обратим внимание
        <ul>
          <li>Полигон сформированный точками `{P_0,P_1,P_2}`, называется управляющий полигон, приблизительно повторяет
            форму кривой;</li>
          <li>`P_0=C(0)` и `P_2=C(1)`;</li>
          <li>Направление касательной к кривой в её концах – параллельны к `P_1-P_0` и `P_2-P_1` (это выведено позже);
          </li>
          <li>Кривая содержится в треугольнике сформированный `P_0 P_1 P_2`.</li>
        </ul>
        <a name="img1_10">
          <object id="svg1_10" data="svg/fig1_10.html" type="image/svg+xml" width="320" height="220"></object>
          <p class="pictxt">Рисунок 1.10. Кривая Безье второй степени</p>
        </a>
      </td>
    </tr>
    <tr>
      <td><b>Пример1.6</b></td>
      <td>`n=3`. Мы имеем `C(u)=(1-u)^3 P_0+3u(1-u)^2 P_1+``3u^2 (1-u)P_2+u^3 P_3`. Примеры кубических кривых Безье
        показаны на <a href="#img1_11a">рис 1.11a</a> по <a href="#img1_11f">рис 1.11f</a>. Обратим внимание
        <ul>
          <li>Управляющий полигон имеет приближённую форму кривых;</li>
          <li>`P_0=C(0)` и `P_3=C(1)`;</li>
          <li>Касательные в конечных точка параллельны `P_1-P_0` и `P_3-P_2`</li>
          <li>Свойство выпуклой оболочки: кривые вписаны в выпуклую оболочку, сформированную управляющими точками (<a
              href="#img1_11c">рис 1.11c</a>);</li>
          <li>Свойство уменьшающегося отклонения: нет прямой линии пе&shy;ресекающей кривую больше раз, чем пересекает
            управляющий полигон кривой (для кривой Безье в трёхмерном пространстве, заменить слова «прямая линия» словом
            «плоскость»). Это свойство кривой Безье демонстрирует, что она следует дово&shy;льно близко от управляющего
            полигона и сильно от него не отклоняется <a href="#img1_11f">рис 1.11f</a>;</li>
          <li>В начале (когда `u=0`) кривая поворачивается в том же направ&shy;лении, что и `P_0 P_1 P_2`. Когда `u=1`
            она поворачивается в направлении `P_1 P_2 P_3`;</li>
          <li>Петля в управляющем полигоне может соответствовать, а может и не соответствовать петле в кривой. Переходом
            между <a href="#img1_11e">рис 1.11e</a> и <a href="#img1_11f">рис 1.11f</a> будет кривая с пиком</li>
        </ul>
        <a name="img1_11a">
          <object id="svg1_11a" data="svg/fig1_11a.html" type="image/svg+xml" width="320" height="220"></object>
          <p class="pictxt">Рисунок 1.11a. Кривые Безье третьей степени</p>
        </a>
        <a name="img1_11b">
          <object id="svg1_11b" data="svg/fig1_11b.html" type="image/svg+xml" width="320" height="220"></object>
          <p class="pictxt">Рисунок 1.11b.</p>
        </a>
        <a name="img1_11c">
          <object id="svg1_11c" data="svg/fig1_11c.html" type="image/svg+xml" width="400" height="400"></object>
          <p class="pictxt">Рисунок 1.11c.</p>
        </a>
        <a name="img1_11d">
          <object id="svg1_11d" data="svg/fig1_11d.html" type="image/svg+xml" width="500" height="400"></object>
          <p class="pictxt">Рисунок 1.11d.</p>
        </a>
        <a name="img1_11e">
          <object id="svg1_11e" data="svg/fig1_11e.html" type="image/svg+xml" width="400" height="300"></object>
          <p class="pictxt">Рисунок 1.11e.</p>
        </a>
        <a name="img1_11f">
          <object id="svg1_11f" data="svg/fig1_11f.html" type="image/svg+xml" width="400" height="300"></object>
          <p class="pictxt">Рисунок 1.11f.</p>
        </a>
      </td>
    </tr>
    <tr>
      <td><b>Пример1.7</b></td>
      <td>`n=6`. <a href="#img1_12">Рис 1.12</a> демонстрирует закрытую кривую Безье шестой степени. Кривая гладкая в
        `C(0)(=C(1))` потому что `P_1-P_0` параллелен `P_6-P_5`. Под гладкостью мы понимаем, что касательные в `u=0`
        и `u=1` имеют одинаковое направление.</td>
    </tr>
  </table>
  <a name="img1_12">
    <object id="svg1_12" data="svg/fig1_12.html" type="image/svg+xml" width="320" height="320"></object>
    <p class="pictxt">Рисунок 1.12. Гладкая замкнутая кривая Безье шестой степени.</p>
  </a>
  <p>В дополнение к ранее упомянутым свойствам, кривые Безье инвариантны при обычных преобразованиях, таких как поворот,
    перемещение и масштабирование; то есть, преобразование применяется к кривой, путём применения к управляющему
    полигону. Мы рассмотрим эту концепцию, более подробно в <a href="#p1">Главе III</a> для B-сплайнов (частным случаем
    которых, являются кривые Безье).</p>
  <p>В любой схеме представления кривой (или поверхности) , выбор базисных функ&shy;ций определяет геометрические
    характеристики схемы. На <a href="#img1_13a">рис 1.13а-г</a> показаны базис&shy;ные функции `{B_(i,n) (u)}` для
    `n=1,2,3,9`. Эти функции имеют следующие свойства:</p>
  <a name="img1_13a">
    <object id="svg1_13a" data="svg/fig1_13a.html" type="image/svg+xml" width="350" height="250"></object>
    <p class="pictxt">Рисунок 1.13a. Многочлен Бернштейна для `n=1`</p>
  </a>
  <a name="img1_13b">
    <object id="svg1_13b" data="svg/fig1_13b.html" type="image/svg+xml" width="350" height="250"></object>
    <p class="pictxt">Рисунок 1.13b. `n=2`</p>
  </a>
  <a name="img1_13c">
    <object id="svg1_13c" data="svg/fig1_13c.html" type="image/svg+xml" width="350" height="250"></object>
    <p class="pictxt">Рисунок 1.13c. `n=3`</p>
  </a>
  <a name="img1_13d">
    <object id="svg1_13d" data="svg/fig1_13d.html" type="image/svg+xml" width="350" height="250"></object>
    <p class="pictxt">Рисунок 1.13d. `n=9`</p>
  </a>
  <table>
    <tr>
      <td><a name="pr1_1"><b>Св.1.1</b></a></td>
      <td>Не отрицательность: `B_(i,n) (u)≥0` для всех `i,n` и `0≤u≤1`;</td>
    </tr>
    <tr>
      <td><a name="pr1_2"><b>Св.1.2</b></a></td>
      <td>Разбиение единицы: `∑_(i=0)^nB_(i,n) (u)=1` для всех `0≤u≤1`;</td>
    </tr>
    <tr>
      <td><a name="pr1_3"><b>Св.1.3</b></a></td>
      <td>`B_(0,n) (0)=B_(n,n) (1)=`1;</td>
    </tr>
    <tr>
      <td><a name="pr1_4"><b>Св.1.4</b></a></td>
      <td>`B_(i,n) (u)` достигает ровно одного максимума на отрезке `[0,1]`, то есть, в `u=i/n`;</td>
    </tr>
    <tr>
      <td><a name="pr1_5"><b>Св.1.5</b></a></td>
      <td>Симметрия: для любого n, множество многочленов `{B_(i,n) (u)}` симметрична по отношению к `u=1⁄2`;</td>
    </tr>
    <tr>
      <td><a name="pr1_6"><b>Св.1.6</b></a></td>
      <td>Рекурсивное определение: `B_(i,n) (u)=(1-u) B_(i,n-1) (u)+uB_(i-1,n-1) (u)` (смотри <a href="#img1_14">рис
          1.14</a>); мы определили `B_(i,n) (u)≡0` если `i<0` или `i>n`;
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <a name="img1_14">
          <object id="svg1_14" data="svg/fig1_14.html" type="image/svg+xml" width="350" height="250"></object>
          <p class="pictxt">Рисунок 1.14. Рекурсивное определение многочлена Бернштейна, `B_{1,3}(u)`</p>
        </a>
        Из <a href="#f1_8">уравнения (1.8)</a> мы имеем `B_{0,0}(u)=1`. Используя <a href="#pr1_6">свойство 1.6</a>,
        линейные и квадратичные многочлены Бернштейна
        `B_{0,1}(u)=(1-u)B_{0,0}(u)+uB_{-1,0}(u)=1-u`
        `B_{1,1}(u)=(1-u)B_{1,0}(u)+uB_{0,0}(u)=u`
        `B_{0,2}(u)=(1-u)B_{0,1}(u)+uB_{-1,1}(u)=(1-u)^2`
        `B_{1,2}(u)=(1-u)B_{1,1}(u)+uB_{0,1}(u)=(1-u)u+u(1-u)=2u(1-u)`
        `B_{2,2}(u)=(1-u)B_{2,1}(u)+uB_{1,1}(u)=u^2`
      </td>
    </tr>
    <tr>
      <td><a name="pr1_7"><b>Св.1.7</b></a></td>
      <td> Производные: `B_{i,n}'(u)={dB_{i,n}(u)}/{du}=n(B_{i-1,n-1}(u)-B_{i,n-1}(u))`
        <p>с `B_{-1,n-1}(u)≡B_{n,n-1}(u)≡0`</p>
        На <a href="#img1_15a">рисунке 1.15a</a> показано определение `B'_{2,5}`, а на <a href="#img1_15b">рисунке
          1.15b</a> - все функции кубической производной.
        <a name="img1_15a">
          <object id="svg1_15a" data="svg/fig1_15a.html" type="image/svg+xml" width="350" height="390"></object>
          <p class="pictxt">Рисунок 1.15a. Производная `B'_{2,5}` по `B_{1,4}` и `B_{2,4}`</p>
        </a>
        <a name="img1_15b">
          <object id="svg1_15b" data="svg/fig1_15b.html" type="image/svg+xml" width="350" height="390"></object>
          <p class="pictxt">Рисунок 1.15b. ппроизводные четырех кубических полиномов Бернштейна `B_{0,3}^'`;
            `B_{1,3}^'`; `B_{2,3}^'`; `B_{3,3}^'`</p>
        </a>
      </td>
    </tr>
  </table>
  <p><a href="#pr1_6">Свойство 1.6</a> дает простые алгоритмы для вычисления значений многочленов Бернштейна при
    фиксированных значениях `u`. Алгоритм А1.2 вычисляет значение `B_{i,n}(u)` для фиксированного `u`.
    Вычисление `B_{1,3}` представлено в <a href="#t1_1">Таблице 1.1.</a></p>

  <a name="t1_1">
    <table class="tbl">
      <caption>Таблица 1.1 Вычисление `B_{1,3}`</caption>
      <tr>
        <td>`0=B_{-2,0}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{-1,2}`</td>
      </tr>
      <tr>
        <td></td>
        <td>&#8600;</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td>`B_{-1,1}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{0,3}`</td>
      </tr>
      <tr>
        <td></td>
        <td>&#8599;</td>
        <td></td>
        <td>&#8600;</td>
      </tr>
      <tr>
        <td>`0=B_{-1,0}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{0,2}`</td>
      </tr>
      <tr>
        <td></td>
        <td>&#8600;</td>
        <td></td>
        <td>&#8599;</td>
        <td></td>
        <td>&#8600;</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td>`B_{0,1}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{1,3}`</td>
      </tr>
      <tr>
        <td></td>
        <td>&#8599;</td>
        <td></td>
        <td>&#8600;</td>
        <td></td>
        <td>&#8599;</td>
      </tr>
      <tr>
        <td>`1=B_{0,0}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{1,2}`</td>
      </tr>
      <tr>
        <td></td>
        <td>&#8600;</td>
        <td></td>
        <td>&#8599;</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td>`B_{1,1}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{2,3}`</td>
      </tr>
      <tr>
        <td></td>
        <td>&#8599;</td>
      </tr>
      <tr>
        <td>`0=B_{1,0}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{2,2}`</td>
      </tr>
    </table>
  </a>

  <p><a name="al1_2"><b>Алгоритм А1.2</b></a></p>
  <pre>
Bernstein(i,n,u,B)
{ /* Вычисление значения многочлена Бернштейна */
  /* Вход: i,n,u  */
  /* Выход: B */
for (j=0; j&lt;=n; j++) /* вычисление колонок */
   temp[j] = 0.0; /* Таблицы 1.1 */
temp[n-i] = 0.0; /* во временный массив */
u1 = 1.0 – u;
for (k=0; k&lt;=n; k++)
   for (j=0; j>=k; j++)
      temp[j] = u1*temp[j] + u*temp[j-1];
B = temp[n];
}
  </pre>

  <p><a href="#al1_3">Алгоритм А1.3</a> вычисляет `n-1` многочлена Бернштейна `n`ой степени с ненуле&shy;вым
    фиксированным `u`. Это позволяет избежать ненужных вычислений нулевых условий. Алгоритм изображен в <a
      href="#t1_2">таблице 1.2</a> для кубического случая.
  </p>

  <a name="t1_2">
    <table class="tbl">
      <caption>Таблица 1.2 Вычисление всех кубических многочленов Бернштейна</caption>
      <tr>
        <td></td>
        <td></td>
        <td>`B_{-1,1}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{0,3}`</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td>&#8599;</td>
      </tr>
      <tr>
        <td>`B_{-1,0}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{0,2}`</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td></td>
        <td>&#8599;</td>
        <td></td>
        <td>&#8600;</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td>`B_{0,1}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{1,3}`</td>
      </tr>
      <tr>
        <td></td>
        <td>&#8599;</td>
        <td></td>
        <td>&#8600;</td>
        <td></td>
        <td>&#8599;</td>
      </tr>
      <tr>
        <td>`1=B_{0,0}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{0,2}`</td>
      </tr>
      <tr>
        <td></td>
        <td>&#8600;</td>
        <td></td>
        <td>&#8599;</td>
        <td></td>
        <td>&#8600;</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td>`B_{1,1}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{2,3}`</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td></td>
        <td>&#8600;</td>
        <td></td>
        <td>&#8599;</td>
      </tr>
      <tr>
        <td>`B_{1,0}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{2,2}`</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td>&#8600;</td>
      </tr>
      <tr>
        <td></td>
        <td></td>
        <td>`B_{2,1}`</td>
        <td></td>
        <td></td>
        <td></td>
        <td>`B_{3,3}`</td>
      </tr>
    </table>
  </a>

  <p><a name="al1_3"><b>Алгоритм А1.3</b></a></p>
  <pre>
AllBernstein(n,u,B)
{ /* Вычисление всех многочленов Бернштейна n-ой степени */
/* Вход: n,u  */
/* Выход: B (массив, B[0], …, B[n]) */
B[0] = 1.0;
u1 = 1.0 – u;
for (j=1; j&lt;=n; j++)
   {
   saved = 0.0;
   for (k=0; k&lt;j; k++)
      {
      Temp = B[k];
      B[k] = saved + u1* temp;
      saved = u*temp;
      }
   B[j] = saved
   }
}
    </pre>
  <p><a href="#al1_4">Алгоритм А1.4</a> комбинирует <a href="#al1_3">А1.3</a> и <a href="#f1_7">уравнение (1.7)</a>
    вычисляет точку на кривой Безье `n`ой степени с фиксированным значением `u`.</p>
  <p><a name="al1_4"><b>Алгоритм А1.4</b></a></p>
  <pre>
PointOnBezierCurve(P,n,u,C)
{ /* Вычисление точку на кривой Безье */
  /* Вход: P,n,u  */
  /* Выход: C (точка) */
AllBernstein(n,u,B)  /* B локальный массив */
C = 0.0;
for (k=0; k&lt;=n; k++)
   C = C + B[k]*P[k];
}
  </pre>
  <p>Используя <a href="#pr1_7">свойство 1.7</a>, легко вывести общее выражение производных кривой Безье</p>

  <p class="formula">`C'(u)={d(sum_{i=0}^n B_{i,n}(u)P_i)}/{du}=sum_{i=0}^nB'_{i,n}(u)P_i`</p>
  <p class="formula">`=sum_{i=0}^n n(B_{i-1,n-1}(u)-B_{i,n-1}(u))P_i`</p>
  <p class="formula">`=nsum_{i=0}^{n-1}B_{i,n-1}(u)(P_{i+1}-P_i)` <a name="f1_9" class="nomer">(1.9)</a></p>

  <p>Из <a href="#f1_9">уравнения (1.9) </a> легко получить формулы для конечных производных кривой Безье, например</p>

  <p class="formula">`C'(0)=n(P_1-P_0)` &emsp; `C''(0)=n(n-1)(P_0-2P_1+P_2)`</p>
  <p class="formula">`C'(1)=n(P_n-P_{n-1})` &emsp; `C''(1)=n(n-1)(P_n-2P_{n-1}+P_{n-2})`
    <a name="f1_10" class="nomer">(1.10)</a></p>

  <p>Обратите внимание, из <a href="#f1_9">уравнений (1.9) </a> и <a href="#f1_10"> (1.0) </a> следует, что</p>

  <ul>
    <li>производные кривой Безье `n`ой степени является кривая Безье `(n-1)`-ой степени;</li>
    <li>выражения для конечных производных в `u=0` и `u=1` симметричны (из-за, конечно, симметрии базисных функций);
    </li>
    <li>`k`-ая производная в конечной точке зависит (в геометрически очень интуитив&shy;ным способом) исключительно от
      `k+1` контрольных точек на том конце.</li>
  </ul>

  <p>Пусть `n=2` и `C(u)=sum_{i=0}^2B_{i,2}(u)P_i`. Тогда</p>
  <p class="formula">`C(u)=(1-u)^2 P_0+2u(1-u)P_1+u^2 P_2`</p>
  <p class="formula">`=(1-u)"("ubrace((1-u)P_0+uP_1)_("линеный")")"+u"("ubrace((1-u)P_1+uP_2)_("линеный")")"`</p>

  <p>Таким образом, `C(u)` получают в виде линейной интерполяции двух кривых Безье первой степени; В частности,
    любая точка на `C(u)` получается три линейной интерпо&shy;ляции.</p>
  <p>Если предположить, что `u=u_0` фиксированно и дать `P_{1,0}=(1-u_0)P_0+u_0 P_1`, `P_{1,1}=(1-u_0)P_1+u_0 P_2`,
    и `P_{2,0}=(1-u_0)P_{1,0}+u_0 P_{1,1}`, следует что `C(u_0)=P_{2,0}`. Ситуация показана на <a href="#p1_6">рис
      1.16</a>, и кубический случай показан на <a href="#p1_7">рис 1.17.</a></p>

  <a name="img1_16">
    <object id="svg1_16" data="svg/fig1_16.html" type="image/svg+xml" width="350" height="220"></object>
    <p class="pictxt">Рисунок 1.16. Получение точки на квадратичной кривой Безье путем многократной линейной
      интерполяции при `u=2⁄5`</p>
  </a>

  <a name="img1_17">
    <object id="svg1_17" data="svg/fig1_17.html" type="image/svg+xml" width="350" height="220"></object>
    <p class="pictxt">Рисунок 1.17. Точка на кубической кривой Безье с помощью повторной линейной интерполяции в `u=2⁄5`
    </p>
  </a>

  <p>Обозначая общую кривую Безье `n`-ой степени как `C_n(P_0,...,P_n)`, мы имеем</p>

  <p class="formula">`C_n(P_0,...,P_n)=(1-u)C_{n-1}(P_0,...,P_{n-1})+uC_{n-1}(P_0,...,P_n)` <a name="f1_11"
      class="nomer">(1.11)</a></p>

  <p>Это следует из рекурсивного определения базисных функций (смотри <a href="#pr1_6">свойство 1.6</a>).
    Фиксированное `u=u_0` и обозначая `P_i` как `P_{0,i}`, <a href="#f1_11">уравнение (1.11)</a> дает рекурсив&shy;ный
    алгоритм для вычисления `C(u_0)=P_{n,0}(u_0)` на кривой Безье `n`-ой степени, т.е.</p>

  <p class="formula">`P_{k,i}(u_0)=(1-u_0)P_{k-1,i}(u_0)+u_0P_{k-1,i+1}(u_0 )` &emsp; где
    `{(k=(1,...,n)),(i=(0,...,n-k)):}`<a name="f1_12" class="nomer">(1.12)</a></p>

  <p><a href="#f1_12">Уравнение (1.12)</a> называются <i>Алгоритм де Кастельжо</i>. Это процесс отрезания углов
    (смотри <a href="#img1_16">рис 1.16</a> и <a href="#img1_17">1.17</a>) который даёт треугольную таблицу точек
    показаную
    в <a href="#t1_3">Таблице 1.3.</a></p>

  <p><a name="al1_5"><b>Алгоритм А1.5</b></a></p>
  <pre>
deCasteljau1(P,n,u,C)
{ /* Вычисление точку на кривой Безье */
  /* Алгоритм де Кастельжо */
  /* Вход: P,n,u  */
  /* Выход: C (точка) */
for (i=0; i&lt;=n; i++)  /* Используя локальный массив таким образом, мы не */
   Q[i] = P[i];       /* разрушаем контрольные точки */
for (k=0; k&lt;=n; k++)
   for (i=0; i&lt;=n-k; i++)
      Q[i] = (1.0 - u)*Q[i] + u*Q[i + 1];
C = Q[0];
}
    </pre>

  <a name="t1_3">
    <table class="tbl" width="500">
      <caption>Таблица 1.3 Точки генерируемые алгоритмом де Кастельжо</caption>
      <tr>
        <td>`P_0`</td>
      </tr>
      <tr>
        <td></td>
        <td>`P_{1,0}`</td>
      </tr>
      <tr>
        <td>`P_1`</td>
        <td></td>
        <td>`P_{2,0}`</td>
      </tr>
      <tr>
        <td></td>
        <td>`P_{1,1}`</td>
      </tr>
      <tr>
        <td>`P_2`</td>
        <td></td>
        <td>`vdots`</td>
      </tr>
      <tr>
        <td>`vdots`</td>
        <td>`vdots`</td>
        <td>`vdots`</td>
        <td></td>
        <td>`P_{n-1,0}`</td>
      </tr>
      <tr>
        <td>`vdots`</td>
        <td>`vdots`</td>
        <td>`vdots`</td>
        <td>`cdots`</td>
        <td></td>
        <td>`P_{n,0}=C(u_0)`</td>
      </tr>
      <tr>
        <td>`vdots`</td>
        <td>`vdots`</td>
        <td>`vdots`</td>
        <td></td>
        <td>`P_{n-1,1}`</td>
      </tr>
      <tr>
        <td>`P_{n-2}`</td>
        <td></td>
        <td>`vdots`</td>
      </tr>
      <tr>
        <td></td>
        <td>`P_{1,n-2}`</td>
      </tr>
      <tr>
        <td>`P_{n-1}`</td>
        <td></td>
        <td>`P_{2,n-2}`</td>
      </tr>
      <tr>
        <td></td>
        <td>`P_{1,n-1}`</td>
      </tr>
      <tr>
        <td>`P_n`</td>
      </tr>
    </table>
  </a>

  <p>Мы закончим этот параграф сравнением Безье и степенных базисных методов. Очевидно, что формула Безье является
    более геометрической из двух. <a href="#f1_10">Уравнение (1.10)</a>, а с выпуклой оболочкой и свойствами
    осцилляции делает кривые Безье более подходящими для интерактивного дизайна кривой. Контрольные точки дают
    разработ&shy;чику более интуитивные ручки для формы кривой, чем коэффициенты степенных бази&shy;сов. Кроме того,
    алгоритм де Кастельжо менее склонен к ошибкам округления, чем алгоритм Горнера. Это интуитивно понятно, если учесть,
    что алгоритм де Кастельжо просто повторяют линейную интерполяцию между точками, в каждом из которых лежат в
    непосредственной близости от кривой. Единственный недостаток формулы Безье является то, что оценка точки является
    менее эффективным (см <a href="chapter1_2.html#al1_1">Алгоритмы A1.1</a>, <a href="#al1_4">A1.4</a>, и <a
      href="#al1_5">A1.5</a>, и <a href="chapter1_5.html#upr1_13">Упражнение 1.13</a> позже в этой главе).</p>

  <footer>
    <a href="chapter1_2.html">Назад</a>
    <a href="..\сontents.html">Содержание</a>
    <a href="chapter1_4.html">Вперёд</a>
  </footer>
</body>

</html>